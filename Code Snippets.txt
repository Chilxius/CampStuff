//Code Snippets


//Goes in Chaser class

  void bounce( Chaser c )
  {
    //Directional Bounce
    if( xPos > c.xPos )
      xSpd = abs(c.xSpd);
    else
      xSpd = -abs(c.xSpd);
      
    if( yPos > c.yPos )
      ySpd = abs(c.ySpd);
    else
      ySpd = -abs(c.ySpd);
      
    bounceDelay = 10;
  }
  
  boolean touching( Chaser c )
  {
    return( dist( c.xPos, c.yPos, xPos, yPos ) < (c.size+size)/2 );
  }  


//Goes in handleChasers()

  //Check for collision
  for(int i = 0; i < currentChasers; i++)
    if( chasers[i].bounceDelay<=0 )
    for(int j = i+1; j < currentChasers; j++)
      if( chasers[i].touching(chasers[j]) )
      {
        chasers[j].bounce(chasers[i]);
        chasers[i].bounce(chasers[j]);
      }

//Goes in handlePlayer()

  //spawns new chaser
  if( currentChasers < chaserCount && score/1000 >= currentChasers )
    currentChasers++;

  //Detects damage
  for(int i = 0; i < currentChasers; i++)
    if( dist( chasers[i].xPos, chasers[i].yPos, mouseX, mouseY ) < 75 )
      health--;

//For Breakout
//Goes in createBricks()

  //Remove duplicate bricks
  for( int i = 0; i < bricks.size(); i++ )
    for( int j = 0; j < bricks.size(); j++ )
      if( i != j && bricks.get(i).health != 0 && bricks.get(j).health != 0 && bricks.get(i).xPos == bricks.get(j).xPos && bricks.get(i).yPos == bricks.get(j).yPos )
        bricks.get(j).health = 0;
